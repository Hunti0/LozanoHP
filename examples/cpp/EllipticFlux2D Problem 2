

3 of 1,859
Progress Report
External
Inbox

Jose Castillo
Jun 9, 2025, 4:08 PM
Hi Hunter, I would like to get a report every Wednesday on your progress. It does not have to be very long. About half a page should do. Best Regards, Prof. Jos

Hunter Lozano
Jun 9, 2025, 4:13 PM
Okay, thank you I will do that.

Hunter Lozano
AttachmentsJun 11, 2025, 2:18 PM
Hi Professor, Since it has been awhile since our last correspondence regarding the project this week's report may be a little longer. Over the past few weeks, I

Jose Castillo
Jun 11, 2025, 3:31 PM
Hi Hunter, I think Jared may be able to provide some guidance with the visualization. I am looking forward to seeing you some problems solved using the mimetic

Hunter Lozano
AttachmentsJun 17, 2025, 5:01 PM
Hi Professor This past week, I implemented real-time visualization into the 3D anisotropic diffusion code using Gnuplot. The output is now generated by extracti

Jose Castillo
Jun 17, 2025, 7:24 PM
Hi Hunter, The plan is that you will contribute the mimetic-flux source code to the MOLE Library. The actual source code should be separated from the example. T

Hunter Lozano
Jun 17, 2025, 7:27 PM
Hello Professor, Okay I will keep that in mind, but to answer your question yes it does compile and run.

Jose Castillo
Jun 17, 2025, 7:37 PM
Great! Thanks

Hunter Lozano
AttachmentsJul 2, 2025, 2:35 PM
Hi Professor, Once I returned from my trip, I focused on improving the modularity and structure of the 3D anisotropic diffusion solver by further separating the

Jared Brzenski
Jul 3, 2025, 3:46 PM
This seems pretty good. The only note I have is to separate the flux operator from the code. Treat it like one of the examples from C++, where there is some cod

Jose Castillo
Jul 4, 2025, 9:51 AM
Hi Hunter, Could you please address the following concerns about you project? Provided by a former student who implemented a mimetic flux operator. Professor, I

Hunter Lozano
AttachmentsJul 9, 2025, 4:15 PM
Hi Professor, This week has been eventful for the project’s development. Initial testing confirmed the student’s concerns that the original code was not working

Hunter Lozano
AttachmentsJul 16, 2025, 4:26 PM
Hello Professor Castillo, This week, I focused on extending the Flux3D.h and Flux3D.cpp components of my 3D parabolic PDE solver to support curvilinear coordina

Jose Castillo
Jul 17, 2025, 5:24 AM
Hi Hunter, I think we are making progress. Here is a review of your report. Please read this carefully and address it. Thanks - Can we see the results of the fl

Hunter Lozano
Jul 20, 2025, 8:38 PM (11 days ago)
Hi Professor Castillo, To verify the accuracy of the 3D heat-equation solver, I compared its output against a smooth, exponentially decaying sine-wave solution

Jose Castillo
Jul 21, 2025, 6:11 AM (10 days ago)
Hunter, We are still missing data to be able to provide good feedback or review. From his explanation: - Need the equation, initial and boundary conditions in m

Jose Castillo
Jul 21, 2025, 6:15 AM (10 days ago)
Hunter, I compared its output against a smooth, exponentially decaying sine-wave solution on a sequence of uniformly refined grids. - Need the equation, initial

Hunter Lozano
Jul 21, 2025, 9:39 AM (10 days ago)
Hi Professor, My apologies for the oversight I’ll get you all of the necessary information when I get off work. In the mean time I saw that I was added to an ov

Jose Castillo
Jul 21, 2025, 10:15 AM (10 days ago)
The plan is for you to start writing your report on the overleaf project. You can see here similar projects, so you get an idea of the format. https://www.csrc.

Hunter Lozano
AttachmentsJul 23, 2025, 4:56 PM (8 days ago)
Hi Professor, This week didn’t go as planned. I’m currently stuck trying to diagnose the convergence rate and order of accuracy of my solver. I had initially ob

Jose Castillo
Jul 23, 2025, 5:04 PM (8 days ago)
to Angel, me, Jared

Hi Hunter,

I am adding Angel, a former student of mine who can provide direct feedback.

That said, there are orders of convergence in time and space.
If you use a second order in time and a second order of space you would expect to get  (2,2) convergence for a problem with smooth coeficientes. If you use euler for time and second order for mimetic you should get (1,2).

I sent you a paper where you can see how to test Only the order in space and the example is a diffusion problem.

I believe that if you focus and work on this every day for some hours you should be done in a week or two.

Best Regards,

Prof. Jose E. Castillo, Ph.D.
Director/Professor
Computational Science Research Center
San Diego State University
Google Scholar
www.csrc.sdsu.edu

Jose Castillo
Attachments
Jul 23, 2025, 6:24 PM (8 days ago)
to me, Jared, Angel

Hunter,

I believe you were advise to start with a simple problem which is using cartesian coordinates.

The problem you need to solve is -divKgrad = f so the discrete equation using mimetic notation is -DKGu= f

You need to implement a flux operator. which is -KG

If you can replicate the solution to the problems in the attached report using MOLE and your Mimetic Flux opertor you will be more than halfway to the finish line.

Best Regards,
Prof. Jose E. Castillo, Ph.D.
Director/Professor
Computational Science Research Center
San Diego State University
Google Scholar
www.csrc.sdsu.edu
 One attachment
  •  Scanned by Gmail

Hunter Lozano <hlozano5063@sdsu.edu>
Attachments
Jul 24, 2025, 6:38 PM (7 days ago)
to Jose

Hi Professor,
I’m reaching out to let you know that I believe I’ve successfully solved Problem 1 on a uniform grid using my flux operator and the MOLE library. Before moving on to Problem 2, I wanted to check if you'd prefer I attempt Problem 1 on a non-uniform grid first, or if you'd like me to move onto Problem 2.

I've attached the code as well as the output for you to verify if you wish.

Thank you,

|   m   |    dx    |   L2 Error   |  L2 Order  |  Max Error  | Max Order |
|--------|----------|--------------|------------|-------------|-----------|
|     50 | 0.0200000000 | 0.0000487386 |          - | 0.0000800073 |         - |
|    100 | 0.0100000000 | 0.0000121286 | 2.0066568708 | 0.0000201391 | 1.9901339550 |
|    200 | 0.0050000000 | 0.0000030248 | 2.0035055979 | 0.0000050520 | 1.9950746398 |
|    400 | 0.0025000000 | 0.0000007553 | 2.0017874597 | 0.0000012652 | 1.9975330742 |
 One attachment
  •  Scanned by Gmail

Jose Castillo
Jul 24, 2025, 7:27 PM (7 days ago)
It looks good, now do the non uniform before moving to problem 2.

Hunter Lozano <hlozano5063@sdsu.edu>
Jul 24, 2025, 8:22 PM (7 days ago)
to Jose, Angel, Jared

Hi,
  
I just wanted to confirm, as far as I can tell, the MOLE C++ library doesn’t currently include built-in operators that support non-uniform grids. Would it be correct to assume that, in this case, I would need to implement the gradient and divergence operators manually if I want to work with a non-uniform mesh?  

Jose Castillo
Jul 24, 2025, 9:48 PM (7 days ago)
Hi, please move to problem 2 for now till we figure out what to do with the non uniform grid issue. You are using second order so you should use 4rth oder opera

Hunter Lozano <hlozano5063@sdsu.edu>
Attachments
Jul 24, 2025, 10:37 PM (7 days ago)
to Jose, Angel, Jared

Hi Professor,

I believe I’m close to solving the problem. Since the MOLE C++ library doesn’t provide gradient and divergence operators for non-uniform grids, I adapted the corresponding MATLAB implementations and ported them to C++. The results look promising — the non-uniform grid shows low error and achieves approximately second-order accuracy. My main concern at the moment is a decrease in accuracy as the grid is refined.

I’ll attach the code and output for your reference. In the meantime, I’ll begin working on Problem 2.


|   m   |    dx    |   L2 Error   |  L2 Order  |  Max Error  | Max Order |
|--------|----------|--------------|------------|-------------|-----------|
|     50 | 0.0200000000 | 0.0000341809 |          - | 0.0000694400 |         - |
|    100 | 0.0100000000 | 0.0000083192 | 2.0386700101 | 0.0000167769 | 2.0492909985 |
|    200 | 0.0050000000 | 0.0000020715 | 2.0057816709 | 0.0000041586 | 2.0123035265 |
|    400 | 0.0025000000 | 0.0000005180 | 1.9995882070 | 0.0000010375 | 2.0030510193 |
 One attachment
  •  Scanned by Gmail

Jared Brzenski
Jul 25, 2025, 9:26 AM (6 days ago)
Remember, to check spatial convergence, you need to keep the time step constant. Pick a dt that works for all the grids ( like 0.0025 ). Then measure the errors

Jose Castillo
AttachmentsJul 25, 2025, 9:40 AM (6 days ago)
Hunter the operators are the same for uniform and nonuniform grids.

Hunter Lozano <hlozano5063@sdsu.edu>
Attachments
Jul 28, 2025, 9:39 PM (3 days ago)
to Jose, Angel, Jared

Hi Professor,

I've still been a bit stuck on the nonuniform grid for Problem 1 so I decided to move onto Problem 2. Unfortunately I've hit another roadblock and cant get the error to decrease or for the order of accuracy to reach second order. I've tried minimalizing the code as best I can and even took out my flux operator to try and find the issue but so far I haven't figured it out yet. I would really appreciate some insight to what I could be missing. 

Thank you,
 One attachment
  •  Scanned by Gmail

Angel Boada
Jul 29, 2025, 9:02 PM (2 days ago)
Hi Hunter, This is Angel Boada, a former PhD student currently working at J&J as a Software Engineer. I can try to help you with the problems you are solving as

Hunter Lozano
Jul 29, 2025, 9:45 PM (2 days ago)
Hi Angel, As long as Professor Castillo is okay with it that would be great, thank you! Also I’ve already forked over the MOLE library so I can send you an invi

Jose Castillo
Jul 29, 2025, 9:54 PM (2 days ago)
It is fine with me.

Hunter Lozano <hlozano5063@sdsu.edu>
Wed, Jul 30, 3:53 PM (1 day ago)
to Jose, Angel, Jared

Hi Professor,
This week, I made progress on the set of problems assigned and successfully completed the uniform grid case for Problem 1. However, I am still working through the non-uniform grid and Problem 2, where I am currently stuck.

As instructed, I have invited everyone in this email thread to my MOLE repository. The code for Problem 2 has been uploaded, and I will provide a README soon for you to review. If you have any questions about the code or have not received the invite please let me know. 

Thank you,

Angel Boada
Jul 30, 2025, 10:11 PM (18 hours ago)
to me, Jose, Jared

Good, I can see the fork. Could you make a pull request and include your changes? That way, they are easy to track.
Yes, I will do that.Thank you, I will do that.Sure!
AI Reply
#include <iostream>
#include <armadillo>
#include <cmath>

#include "mole.h"
#include <vector>

using namespace arma;
using std::cout;
using std::endl;

double exact_u(double x, double y) {
    const double lambda = 1.0;
    return std::exp(lambda * (x + y) / 2.0) / (std::exp(lambda) - 1.0);
}

double rhs_f(double x, double y) {
    const double lambda = 1.0;
    return (lambda * lambda) * std::exp(lambda * (x + y) / 2.0) / (2.0 * (std::exp(lambda) - 1.0));
}

int main() {
    std::vector<u32> Ns = {10, 20, 40, 80};
    u16 k = 2; 
    cout << "Grid Size\tL2 Error\tRate" << endl;
    double prev = 0.0;

    for (size_t ni = 0; ni < Ns.size(); ++ni) {
        u32 m = Ns[ni], n = Ns[ni];
        double Lx = 1.0, Ly = 1.0;
        double dx = Lx / (m + 1), dy = Ly / (n + 1);

        vec x = linspace(0.0, Lx, m + 2);
        vec y = linspace(0.0, Ly, n + 2);

        // Build analytic solution and RHS on grid
        vec uex((m+2)*(n+2)), f((m+2)*(n+2));
        for (u32 i = 0; i < m + 2; ++i)
            for (u32 j = 0; j < n + 2; ++j) {
                u32 idx = i * (n + 2) + j;
                uex(idx) = exact_u(x(i), y(j));
                f(idx)   = rhs_f(x(i), y(j));
            }

        // Assemble Laplacian operator
        Laplacian L(k, m, n, dx, dy);
        sp_mat Amat = static_cast<sp_mat>(L);

        // Reaction term
        const double lambda = 1.0;
        for (u32 idx = 0; idx < (m+2)*(n+2); ++idx)
            Amat(idx, idx) += lambda;

        // Robin boundary condition parameters
        const double alpha = -std::exp(lambda);
        const double beta  = (std::exp(lambda) - 1.0) / lambda;
        sp_mat BCmat = static_cast<sp_mat>(
            RobinBC(k, m, dx, n, dy, alpha, beta));
        Amat = Amat + BCmat;


        vec sol = spsolve(Amat, f);

        // Compute global L2 error
        double err = norm(sol - uex, 2) / norm(uex, 2);

        cout << m << "x" << n << "\t" << err;
        if (ni > 0) cout << "\t" << std::log2(prev / err);
        cout << endl;
        prev = err;
    }
    return 0;
}
